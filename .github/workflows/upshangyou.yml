name: Sync Upstream Code & Releases (Smart Mirror)

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

env:
  KEEP_LOCAL_RELEASES: true  # 保持为 true，保护本地已同步的发行版

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup git identity
        run: |
          git config --global user.name "woshishiq1"
          git config --global user.email "1987669587@qq.com"

      - name: Fetch upstream
        run: |
          git remote add upstream https://github.com/Qeccentric/GlobalTraveling.git || true
          git fetch upstream main --tags

      - name: Sync upstream code (Mirror Commit Message)
        run: |
          set -e
          # 1. 备份本地 Workflows (包含你的同步脚本)
          mkdir -p /tmp/my-workflows
          cp -a .github/workflows/* /tmp/my-workflows/ 2>/dev/null || true

          # 2. 获取上游最新的提交信息
          UPSTREAM_MSG=$(git log upstream/main -1 --format=%s)
          echo "Latest upstream message: $UPSTREAM_MSG"

          # 3. 强制重置到上游状态
          git checkout -B main
          git reset --hard upstream/main

          # 4. 还原自己的 Workflows (cp -n 确保如果上游新增了 workflow 也会被保留)
          mkdir -p .github/workflows
          cp -n /tmp/my-workflows/* .github/workflows/ 2>/dev/null || true

          # 5. 检查是否有实质性代码变化 (排除 Workflows 目录后的对比)
          # 注意：这里的逻辑是如果上游代码变了，或者上游新加了 Workflow，都会触发
          if git diff --quiet HEAD origin/main -- . ':!.github/workflows'; then
            echo "No meaningful upstream changes detected. Skipping commit."
          else
            echo "Upstream changes detected. Committing with upstream message..."
            git add -A
            # 使用上游的提交信息，实现“视觉完美同步”
            git commit -m "$UPSTREAM_MSG" || true
            git push origin main --force
          fi
          # 始终同步标签
          git push origin --tags --force

      - name: Sync releases (smart mirror)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          UPSTREAM_REPO="Qeccentric/GlobalTraveling"
          TARGET_REPO="${{ github.repository }}"

          UPSTREAM_TAGS=$(gh release list --repo "$UPSTREAM_REPO" --limit 100 --json tagName -q '.[].tagName' | sort || true)
          TARGET_TAGS=$(gh release list --repo "$TARGET_REPO" --limit 100 --json tagName -q '.[].tagName' | sort || true)

          mkdir -p /tmp/release-assets
          
          if [ "${{ env.KEEP_LOCAL_RELEASES }}" = "false" ]; then
            for tag in $TARGET_TAGS; do
              if ! echo "$UPSTREAM_TAGS" | grep -Fxq "$tag"; then
                gh release delete "$tag" --repo "$TARGET_REPO" --yes || true
                git push origin ":refs/tags/$tag" || true
              fi
            done
          fi

          for tag in $UPSTREAM_TAGS; do
            cd /tmp/release-assets && rm -rf *
            rel_json=$(gh release view "$tag" --repo "$UPSTREAM_REPO" --json name,body,isPrerelease)
            rel_name=$(echo "$rel_json" | jq -r '.name')
            rel_body=$(echo "$rel_json" | jq -r '.body')
            rel_is_pre=$(echo "$rel_json" | jq -r '.isPrerelease')

            if gh release view "$tag" --repo "$TARGET_REPO" &>/dev/null; then
              gh release edit "$tag" --repo "$TARGET_REPO" --title "$rel_name" --notes "$rel_body" --prerelease=$rel_is_pre
            else
              gh release download "$tag" --repo "$UPSTREAM_REPO" --skip-existing || true
              ARGS=("$tag" --repo "$TARGET_REPO" --title "$rel_name" --notes "$rel_body")
              [ "$rel_is_pre" = "true" ] && ARGS+=("--prerelease")
              mapfile -t files < <(find . -type f ! -name ".*")
              [[ ${#files[@]} -gt 0 ]] && gh release create "${ARGS[@]}" "${files[@]}" || gh release create "${ARGS[@]}"
            fi
          done
